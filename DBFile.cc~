#include "TwoWayList.h"
#include "Record.h"
#include "Schema.h"
#include "File.h"
#include "Comparison.h"
#include "ComparisonEngine.h"
#include "DBFile.h"
#include "Defs.h"
#include <string.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>

// stub file .. replace it with your own DBFile.cc

DBFile::DBFile () {
	metaDataFileName="metaData.txt";
	flag=-1;
rwBuffer=new Page();
}

/*
*check if file path is NULL, if yes return 0 otherwise
*create a new file and return 1
*/
int DBFile::Create (char *f_path, fType f_type, void *startup) {
	if(f_path!=NULL)
	{
	dbFile.Open(0,f_path);							
	dbFile.AddPage(rwBuffer,0);
	dbFile.Close();
	Open(f_path);
	return 1;
	}
	else
	return 0;
}

/** Open the filepath provided by loadpath.
*IF Loop through records in the file and load it into the temp 	record variable
* Keep appending it to a page and when the page is full write this page out 
* to the disk using an instance of file class. Clear the page buffer for further
* loads
*/
void DBFile::Load (Schema &f_schema, char *loadpath) {

	cout<<loadpath<<endl;	
	FILE *tableFile = fopen (loadpath, "r");
int count=0;	 
        Record temp;
	if(tableFile!=NULL)
	{
        while (temp.SuckNextRecord (&f_schema, tableFile) == 1) {
			//cout<<"inside while"<<endl;
			if(!rwBuffer->Append(&temp))
			{
				dbFile.AddPage(rwBuffer,writePage);
				writePage++;
				rwBuffer->EmptyItOut();
				rwBuffer->Append(&temp);
				cout<<writePage<<endl;
			}
	count++;
	}
	dbFile.AddPage(rwBuffer,writePage);
	flag=1;
	fclose(tableFile);
	}
	else
		cout<<"check yout loadPath"<<endl;
}

/**
*open the DB file, success case returns 1 and failure case returned with 0
*/


int DBFile::Open (char *f_path) {

if(f_path!=NULL)
{
	dbFile.Open(1,f_path);				//first parameter is non zero so that files not created again and is opened in read write mode.

	ifstream mdFile(metaDataFileName);
	string line;
	char* pch;
	
	 if (mdFile.is_open())
	  {
		/*
		 * read first line and tokenize it to store the value of read_page
		 */ 
	    getline (mdFile,line);
		pch = strtok (&line[0]," ");
		pch = strtok (NULL," ");
	    readPage=atoi(pch);		//convert char* to int
	    /*
		 * read first line and tokenize it to store the value of read_record
		 */ 
	    getline (mdFile,line);
		pch = strtok (&line[0]," ");
		pch = strtok (NULL," ");
	    readRecord=atoi(pch);		//convert char* to int
	    /*
		 * read first line and tokenize it to store the value of write_page
		 */ 
	    getline (mdFile,line);
		pch = strtok (&line[0]," ");
		pch = strtok (NULL," ");
	    writePage=atoi(pch);		//convert char* to int
	    
		mdFile.close();	
		return 1;
	}
}
else
return 0;
}	
 

/**
*Move the pointer to first record in file
*/
void DBFile::MoveFirst () {
	readPage=1;
	readRecord=0;
}

int DBFile::Close () {
	
	
	//Appending the write buffer to end of file to add remaining elements in the buffer
	if(flag==1)
	{
	dbFile.AddPage(rwBuffer,writePage);
	}
	
	dbFile.Close();
	ofstream mdFile;
	mdFile.open(metaDataFileName);
	mdFile<<"readPage "<<readPage<<endl;
	mdFile<<"readRecord "<<readRecord<<endl;
	mdFile<<"writePage "<<writePage<<endl;
	mdFile.close(); 
	return 1;
}

void DBFile::Add (Record &rec) {
	//cout<<"in 1"<<endl;
					//rwBuffer->EmptyItOut();
			if(flag==0||(flag==-1&&dbFile.GetLength()>0))
			{
					dbFile.GetPage(rwBuffer,writePage);
					flag=1;
		
			}
			else
			flag=1;
			if(!rwBuffer->Append(&rec))
			{
				dbFile.AddPage(rwBuffer,writePage);
				writePage++;
				rwBuffer->EmptyItOut();
				rwBuffer->Append(&rec);
				
			}

		
return;
}

int DBFile::GetNext (Record &fetchme) {
	
	if(flag==-1&&dbFile.GetLength()==0)
	return 0;
	
	if(flag!=0)
	{
		if(flag==1)
		{
		dbFile.AddPage(rwBuffer,writePage);
		rwBuffer->EmptyItOut();
		}
		dbFile.GetPage(rwBuffer,readPage);
		flag=0;
		for(int i=0;i<readRecord;i++)
		{
			Record temp;
			rwBuffer->GetFirst(&temp);
		}
		
	}
		
	if(!rwBuffer->GetFirst(&fetchme))
	{
		readRecord=0;
		int noOfPages=dbFile.GetLength()-1;
		if(readPage+1<noOfPages)
		{
			readPage=readPage+1;
			dbFile.GetPage(rwBuffer,readPage);
			rwBuffer->GetFirst(&fetchme);
				
		}
		else
		return 0;
	}
	readRecord++;
	return 1;
}
	

int DBFile::GetNext (Record &fetchme, CNF &cnf, Record &literal) {
int cnt=0;
Schema x("catalog","nation");
while(GetNext(fetchme))
{
	//fetchme.Print(&x);
	if(compEngine.Compare (&fetchme, &literal, &cnf)) 
		{
		return 1;			
		}   
}

return 0;
}


DBFile::~DBFile(){
	delete rwBuffer;
}
